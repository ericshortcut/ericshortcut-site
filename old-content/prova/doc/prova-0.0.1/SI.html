<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SI</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_SI.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/SI.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">prova-0.0.1: Corre&#231;&#227;o das provas da FATEC BS</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Alexandre Garcia, 2016
                  Eric Andrade, 2016</td></tr><tr><th>License</th><td>GPL-3</td></tr><tr><th>Maintainer</th><td>no@reply.c-m</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">SI</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Prova de Sistemas para Internet
Coment&#225;rios <code>#Corre&#231;&#227;o de Prova</code>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:exerc-237-cio1">exerc&#237;cio1</a> :: <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:exerc-237-cio2">exerc&#237;cio2</a> :: <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:exerc-237-cio3">exerc&#237;cio3</a> :: <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> ()</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:exerc-237-cio1" class="def">exerc&#237;cio1</a> :: <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> () <a href="src/SI.html#exerc%EDcio1" class="link">Source</a> <a href="#v:exerc-237-cio1" class="selflink">#</a></p><div class="doc"><ul><li>Corre&#231;&#227;o da prova de Sistemas para internet</li><li>1. (valor 2.5 pontos)</li><li><p>(a) (1.0) Monte uma express&#227;o lambda para o que se pede</p><ul><li><p>i. Lambda para verificar se uma lista tem tamanho 9.</p><pre>(xs -&gt; <code><a href="../base-4.9.0.0/Data-Foldable.html#v:length">length</a></code> xs == 9 )
        ou
(xs -&gt; (<code><a href="../base-4.9.0.0/Data-Foldable.html#v:length">length</a></code> xs) == 9 )
</pre></li><li><p>ii. Lambda para filtrar palavras de tamanho maior que 30 de um array de Strings xs.</p><pre>(xss -&gt; <code><a href="../base-4.9.0.0/GHC-OldList.html#v:filter">filter</a></code> (xs -&gt; <code><a href="../base-4.9.0.0/Data-Foldable.html#v:length">length</a></code> xs &lt;= 30 ) xss)
</pre></li><li><p>iii. Lambda para receber uma String s e retorn&#225; -la em ordem reversa sendo do tipo <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> String.</p><pre>(xs -&gt;  <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> (<code><a href="../base-4.9.0.0/GHC-OldList.html#v:reverse">reverse</a></code> xs))
</pre></li><li><p>iv. Lambda para checar se um n&#250;mero positivo.</p><pre>(x -&gt; x &gt;= 0 )
</pre></li></ul></li><li>(b) (0.5) D&#234; o tipo das seguintes fun&#231;&#245;es</li><li><p>i. x -&gt; [ &#8221;Ola&#8221; ++ x ]</p><pre>   ( x -&gt; [ <a href="Ola.html">Ola</a> ++ x ]) :: [<code><a href="../base-4.9.0.0/Data-Char.html#t:Char">Char</a></code>] -&gt; [[<code><a href="../base-4.9.0.0/Data-Char.html#t:Char">Char</a></code> ]]
   </pre><ul><li><p>ii. t -&gt; <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> $ t == <a href="True.html">True</a></p><pre>(t -&gt; <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> $ t == <a href="True.html">True</a>) :: [[<code><a href="../base-4.9.0.0/Data-Char.html#t:Char">Char</a></code>]] -&gt; <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../base-4.9.0.0/Data-Bool.html#t:Bool">Bool</a></code>
</pre></li></ul></li><li>(c) (1) Fa&#231;a fun&#231;&#245;es (dando o tipo da fun&#231;&#227;o e da forma mais gen&#233;rica poss&#237;vel) para o que se pede</li><li><p>i. Uma fun&#231;&#227;o que receba uma lista e a devolva sem os dois primeiros elementos (Dica: pattern matching) .</p><pre>   semDois :: [a] -&gt; [a]
   semDois [] = []
   semDois (x:xs) = x : xs
   semDois (_:_:xs) = xs
          ou
   semDois :: [a] -&gt; [a]
   semDois xs = <code><a href="../base-4.9.0.0/GHC-OldList.html#v:tail">tail</a></code> ( <code><a href="../base-4.9.0.0/GHC-OldList.html#v:tail">tail</a></code> xs )
   </pre><ul><li><p>ii. Uma fun&#231;&#227;o que receba dois <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> Int e retorne o menor deles (Dica: pattern matching).</p><pre>doisMaybeMenor :: <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> Int -&gt; <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../base-4.9.0.0/Data-Int.html#t:Int">Int</a></code> -&gt; <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../base-4.9.0.0/Data-Int.html#t:Int">Int</a></code>
doisMaybeMenor (<code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> x) (<code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> y)
                            | x &gt; y = <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> y
                            | otherwise = <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> x
doisMaybeMenor _ _ = <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Nothing">Nothing</a></code>
            ou
doisMaybeMenor :: <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../base-4.9.0.0/Data-Int.html#t:Int">Int</a></code> -&gt; <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../base-4.9.0.0/Data-Int.html#t:Int">Int</a></code> -&gt; <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="../base-4.9.0.0/Data-Int.html#t:Int">Int</a></code>
doisMaybeMenor (<code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> x) (<code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> y) = <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Just">Just</a></code> (min x y)
doisMaybeMenor _ _ = <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Nothing">Nothing</a></code>
</pre></li><li>iii. Uma fun&#231;&#227;o que receba um valor qualquer e retorne <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Nothing">Nothing</a></code>.</li></ul><pre>       retornaNothing :: a -&gt; <code><a href="../base-4.9.0.0/Data-Maybe.html#t:Maybe">Maybe</a></code> a
       retornaNothing _ = <code><a href="../base-4.9.0.0/Data-Maybe.html#v:Nothing">Nothing</a></code>
   </pre><ul><li><p>iv. Uma fun&#231;&#227;o que receba um valor e verifique se este &#233; maior que seu mempty.</p><pre>maiorQueMempty :: (<code><a href="../base-4.9.0.0/Data-Ord.html#t:Ord">Ord</a></code> a )=&gt; a -&gt; <code><a href="../base-4.9.0.0/Data-Bool.html#t:Bool">Bool</a></code>)
maiorQueMempty x = ( x ) /= <code><a href="../base-4.9.0.0/Data-Monoid.html#v:mempty">mempty</a></code> )

</pre></li></ul></li></ul></div></div><div class="top"><p class="src"><a id="v:exerc-237-cio2" class="def">exerc&#237;cio2</a> :: <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> () <a href="src/SI.html#exerc%EDcio2" class="link">Source</a> <a href="#v:exerc-237-cio2" class="selflink">#</a></p><div class="doc"><ul><li><p>2. (valor 2.5 pontos) Considere a fun&#231;&#227;o</p><pre>module Aula1 where

data Tupla a = Tupla a a deriving Show

instance <code><a href="../base-4.9.0.0/Data-Functor.html#t:Functor">Functor</a></code> Tupla where
 <code><a href="../base-4.9.0.0/Data-Functor.html#v:fmap">fmap</a></code> f (Tupla x y ) = Tupla (<code><a href="../base-4.9.0.0/Data-Function.html#v:id">id</a></code>.f $ y) (f.<code><a href="../base-4.9.0.0/Data-Function.html#v:id">id</a></code> $ x)
</pre><p>e responda</p><ul><li><p>(a) (0.25) Qual o valor da express&#227;o fmap (x-&gt;x&lt;3)$ Tupla 4 2?</p><pre>Tupla <code><a href="../base-4.9.0.0/Data-Bool.html#v:True">True</a></code> <code><a href="../base-4.9.0.0/Data-Bool.html#v:False">False</a></code>
</pre></li><li><p>(b) (0.25) Qual o valor da express&#227;o :t Tupla &quot;W&quot; &quot;M&quot;?</p><pre>Tupla &quot;W&quot; &quot;M&quot; :: Tupla [<code><a href="../base-4.9.0.0/Data-Char.html#t:Char">Char</a></code>]
</pre></li><li><p>(c) (0.25) Qual o valor de fmap id $ Tupla 4 7?</p><pre><code><a href="../base-4.9.0.0/Data-Functor.html#v:fmap">fmap</a></code> <code><a href="../base-4.9.0.0/Data-Function.html#v:id">id</a></code> $ Tupla 4 7
</pre></li><li><p>(d) (0.5) Fa&#231;a uma inst&#226;ncia de Eq para Tupla, onde duas Tuplas s&#227;o iguais se o primeiro elemento de uma for igual ao segundo elemento da outra;</p><pre>instance (<code><a href="../base-4.9.0.0/Data-Eq.html#t:Eq">Eq</a></code> a) =&gt; <code><a href="../base-4.9.0.0/Data-Eq.html#t:Eq">Eq</a></code> (Tupla a ) where
    (<code><a href="../base-4.9.0.0/Data-Eq.html#v:-61--61-">==</a></code>) (Tupla a _) (Tupla b _) = a == b
</pre></li></ul></li><li><p>(e) (0.25) Qual o valor de :t Tupla mempty mempty?;</p><pre>Tupla <code><a href="../base-4.9.0.0/Data-Monoid.html#v:mempty">mempty</a></code> <code><a href="../base-4.9.0.0/Data-Monoid.html#v:mempty">mempty</a></code> :: <code><a href="../base-4.9.0.0/Data-Monoid.html#t:Monoid">Monoid</a></code> a =&gt; <code>Tupla</code> a
</pre></li><li><p>(f) (0.5) Fa&#231;a uma inst&#226;ncia de Show para tupla que dado (Tupla x y) mostre na tela &#8220;fst: x =&gt; snd: y&#8221;;</p><pre>instance (<code><a href="../base-4.9.0.0/Text-Show.html#t:Show">Show</a></code> a) =&gt; <code><a href="../base-4.9.0.0/Text-Show.html#t:Show">Show</a></code> (Tupla a ) where
    <code><a href="../base-4.9.0.0/Text-Show.html#v:show">show</a></code> (Tupla x y) = &quot;fst: &quot; ++ show x ++&quot; =&gt; snd: &quot; ++ show y
</pre></li><li><p>(g) (0.5)Do jeito que est&#225; oc&#243;digo e sem qualquer altera&#231;&#227;o,&#233; poss&#237;vel calcular a express&#227;o Tupla 1 2 <code>&lt;&gt;</code> Tupla 2 3? Justifique.</p><pre>&gt;N&#227;o &#233; poss&#237;vel, n&#227;o existe inst&#226;ncia de monoid. Ent&#227;o o haskell n&#227;o sabe como combinar dois tipos <a href="Tupla.html">Tupla</a>
</pre></li></ul></div></div><div class="top"><p class="src"><a id="v:exerc-237-cio3" class="def">exerc&#237;cio3</a> :: <a href="../base-4.9.0.0/System-IO.html#t:IO">IO</a> () <a href="src/SI.html#exerc%EDcio3" class="link">Source</a> <a href="#v:exerc-237-cio3" class="selflink">#</a></p><div class="doc"><ul><li>3. (valor 2.5 pontos)</li><li><p>(a) (0.25) Crie um tipo que represente os quatros naipes de um baralho (Ouros, espadas, copas e paus).</p><pre>   data Naipe = Ouros | Espadas | Copas | Paus deriving (Show)
   </pre><ul><li><p>(b) (0.25) Crie o tipo Valor que tenha 13 value constructors representando os 9 n&#250;meros do baralho (2 a 9) e as figuras A, J, Q, K.</p><pre>data Valor = A | Um | Dois | Tres | Quatro | Cinco | Seis | Sete | Oito | Nove | J | Q | K deriving Show
</pre></li><li><p>(c) (0.5) Crie o tipo Carta que possua um Valor e um Naipe como campos.</p><pre>data Carta = Carta Valor Naipe deriving Show
</pre></li><li><p>(d) (1.0) Fa&#231;a a fun&#231;ao veremelhoFigura que filtre as figuras de naipes vermelhos (Ouros e Copas).</p><pre>veremelhoFigura :: [Carta] -&gt; [Carta]
veremelhoFigura [] = []
veremelhoFigura ((Carta v Ouros):xs) = (Carta v Ouros) : veremelhoFigura xs
veremelhoFigura ((Carta v Copas):xs) = (Carta v Copas) : veremelhoFigura xs
veremelhoFigura (_:xs) = veremelhoFigura xs
</pre></li><li><p>(e) (0.5) Fa&#231;a a fun&#231;&#227;o isBlackJack que recebe duas cartas e retorna se este par forma ou n&#227;o um blackjack. Um black &#233; sempre formado por um A(&#225; s) seguido de J, Q ou K.</p><pre>isBlackJack :: <code>Carta</code> -&gt; <code>Carta</code> -&gt; <code><a href="../base-4.9.0.0/Data-Bool.html#t:Bool">Bool</a></code>
isBlackJack (Carta v A) (Carta v J) = True
isBlackJack (Carta v J) (Carta v A) = True
isBlackJack (Carta v A) (Carta v Q)  = True
isBlackJack (Carta v Q) (Carta v A)  = True
isBlackJack (Carta v A) (Carta v K)  = True
isBlackJack (Carta v K) (Carta v A)  = True
isBlackJack _ _ = False
</pre></li></ul></li></ul></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.2</p></div></body></html>