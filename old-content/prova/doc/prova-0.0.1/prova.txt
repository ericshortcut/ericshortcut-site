-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Correção das provas da FATEC BS
--   
--   Correção das provas da FATEC BS - ADS (Manhã/Noite) - SI (tarde)
@package prova
@version 0.0.1


-- | Prova de Sistemas para Internet Comentários <tt>#Correção de
--   Prova</tt>.
module SI

-- | <ul>
--   <li>Correção da prova de Sistemas para internet</li>
--   <li>1. (valor 2.5 pontos)</li>
--   <li>(a) (1.0) Monte uma expressão lambda para o que se pede<ul><li>i.
--   Lambda para verificar se uma lista tem tamanho 9.<pre>(xs -&gt;
--   <a>length</a> xs == 9 ) ou (xs -&gt; (<a>length</a> xs) == 9 )
--   </pre></li><li>ii. Lambda para filtrar palavras de tamanho maior que
--   30 de um array de Strings xs.<pre>(xss -&gt; <a>filter</a> (xs -&gt;
--   <a>length</a> xs &lt;= 30 ) xss) </pre></li><li>iii. Lambda para
--   receber uma String s e retorná -la em ordem reversa sendo do tipo
--   <a>Maybe</a> String.<pre>(xs -&gt; <a>Just</a> (<a>reverse</a> xs))
--   </pre></li><li>iv. Lambda para checar se um número positivo.<pre>(x
--   -&gt; x &gt;= 0 ) </pre></li></ul></li>
--   <li>(b) (0.5) Dê o tipo das seguintes funções</li>
--   <li>i. x -&gt; [ ”Ola” ++ x ]<pre> ( x -&gt; [ <a>Ola</a> ++ x ]) ::
--   [<a>Char</a>] -&gt; [[<a>Char</a> ]] </pre><ul><li>ii. t -&gt;
--   <a>Just</a> $ t == <a>True</a><pre>(t -&gt; <a>Just</a> $ t ==
--   <a>True</a>) :: [[<a>Char</a>]] -&gt; <a>Maybe</a> <a>Bool</a>
--   </pre></li></ul></li>
--   <li>(c) (1) Faça funções (dando o tipo da função e da forma mais
--   genérica possível) para o que se pede</li>
--   <li>i. Uma função que receba uma lista e a devolva sem os dois
--   primeiros elementos (Dica: pattern matching) .<pre> semDois :: [a]
--   -&gt; [a] semDois [] = [] semDois (x:xs) = x : xs semDois (_:_:xs) =
--   xs ou semDois :: [a] -&gt; [a] semDois xs = <a>tail</a> ( <a>tail</a>
--   xs ) </pre><ul><li>ii. Uma função que receba dois <a>Maybe</a> Int e
--   retorne o menor deles (Dica: pattern matching).<pre>doisMaybeMenor ::
--   <a>Maybe</a> Int -&gt; <a>Maybe</a> <a>Int</a> -&gt; <a>Maybe</a>
--   <a>Int</a> doisMaybeMenor (<a>Just</a> x) (<a>Just</a> y) | x &gt; y =
--   <a>Just</a> y | otherwise = <a>Just</a> x doisMaybeMenor _ _ =
--   <a>Nothing</a> ou doisMaybeMenor :: <a>Maybe</a> <a>Int</a> -&gt;
--   <a>Maybe</a> <a>Int</a> -&gt; <a>Maybe</a> <a>Int</a> doisMaybeMenor
--   (<a>Just</a> x) (<a>Just</a> y) = <a>Just</a> (min x y) doisMaybeMenor
--   _ _ = <a>Nothing</a> </pre></li><li>iii. Uma função que receba um
--   valor qualquer e retorne <a>Nothing</a>.</li></ul><pre> retornaNothing
--   :: a -&gt; <a>Maybe</a> a retornaNothing _ = <a>Nothing</a>
--   </pre><ul><li>iv. Uma função que receba um valor e verifique se este é
--   maior que seu mempty.<pre>maiorQueMempty :: (<a>Ord</a> a )=&gt; a
--   -&gt; <a>Bool</a>) maiorQueMempty x = ( x ) /= <a>mempty</a> )
--   </pre></li></ul></li>
--   </ul>
exercício1 :: IO ()

-- | <ul>
--   <li>2. (valor 2.5 pontos) Considere a função<pre>module Aula1 where
--   data Tupla a = Tupla a a deriving Show instance <a>Functor</a> Tupla
--   where <a>fmap</a> f (Tupla x y ) = Tupla (<a>id</a>.f $ y)
--   (f.<a>id</a> $ x) </pre>e responda<ul><li>(a) (0.25) Qual o valor da
--   expressão fmap (x-&gt;x&lt;3)$ Tupla 4 2?<pre>Tupla <a>True</a>
--   <a>False</a> </pre></li><li>(b) (0.25) Qual o valor da expressão :t
--   Tupla "W" "M"?<pre>Tupla "W" "M" :: Tupla [<a>Char</a>]
--   </pre></li><li>(c) (0.25) Qual o valor de fmap id $ Tupla 4
--   7?<pre><a>fmap</a> <a>id</a> $ Tupla 4 7 </pre></li><li>(d) (0.5) Faça
--   uma instância de Eq para Tupla, onde duas Tuplas são iguais se o
--   primeiro elemento de uma for igual ao segundo elemento da
--   outra;<pre>instance (<a>Eq</a> a) =&gt; <a>Eq</a> (Tupla a ) where
--   (<a>==</a>) (Tupla a _) (Tupla b _) = a == b </pre></li></ul></li>
--   <li>(e) (0.25) Qual o valor de :t Tupla mempty mempty?;<pre>Tupla
--   <a>mempty</a> <a>mempty</a> :: <a>Monoid</a> a =&gt; <tt>Tupla</tt> a
--   </pre></li>
--   <li>(f) (0.5) Faça uma instância de Show para tupla que dado (Tupla x
--   y) mostre na tela “fst: x =&gt; snd: y”;<pre>instance (<a>Show</a> a)
--   =&gt; <a>Show</a> (Tupla a ) where <a>show</a> (Tupla x y) = "fst: "
--   ++ show x ++" =&gt; snd: " ++ show y </pre></li>
--   <li>(g) (0.5)Do jeito que está ocódigo e sem qualquer alteração,é
--   possível calcular a expressão Tupla 1 2 <tt>&lt;&gt;</tt> Tupla 2 3?
--   Justifique.<pre>&gt;Não é possível, não existe instância de monoid.
--   Então o haskell não sabe como combinar dois tipos <a>Tupla</a>
--   </pre></li>
--   </ul>
exercício2 :: IO ()

-- | <ul>
--   <li>3. (valor 2.5 pontos)</li>
--   <li>(a) (0.25) Crie um tipo que represente os quatros naipes de um
--   baralho (Ouros, espadas, copas e paus).<pre> data Naipe = Ouros |
--   Espadas | Copas | Paus deriving (Show) </pre><ul><li>(b) (0.25) Crie o
--   tipo Valor que tenha 13 value constructors representando os 9 números
--   do baralho (2 a 9) e as figuras A, J, Q, K.<pre>data Valor = A | Um |
--   Dois | Tres | Quatro | Cinco | Seis | Sete | Oito | Nove | J | Q | K
--   deriving Show </pre></li><li>(c) (0.5) Crie o tipo Carta que possua um
--   Valor e um Naipe como campos.<pre>data Carta = Carta Valor Naipe
--   deriving Show </pre></li><li>(d) (1.0) Faça a funçao veremelhoFigura
--   que filtre as figuras de naipes vermelhos (Ouros e
--   Copas).<pre>veremelhoFigura :: [Carta] -&gt; [Carta] veremelhoFigura
--   [] = [] veremelhoFigura ((Carta v Ouros):xs) = (Carta v Ouros) :
--   veremelhoFigura xs veremelhoFigura ((Carta v Copas):xs) = (Carta v
--   Copas) : veremelhoFigura xs veremelhoFigura (_:xs) = veremelhoFigura
--   xs </pre></li><li>(e) (0.5) Faça a função isBlackJack que recebe duas
--   cartas e retorna se este par forma ou não um blackjack. Um black é
--   sempre formado por um A(á s) seguido de J, Q ou K.<pre>isBlackJack ::
--   <tt>Carta</tt> -&gt; <tt>Carta</tt> -&gt; <a>Bool</a> isBlackJack
--   (Carta v A) (Carta v J) = True isBlackJack (Carta v J) (Carta v A) =
--   True isBlackJack (Carta v A) (Carta v Q) = True isBlackJack (Carta v
--   Q) (Carta v A) = True isBlackJack (Carta v A) (Carta v K) = True
--   isBlackJack (Carta v K) (Carta v A) = True isBlackJack _ _ = False
--   </pre></li></ul></li>
--   </ul>
exercício3 :: IO ()


-- | Prova de ADS Noite Comentários <tt>#Correção de Prova </tt>.
module ADSN

-- | <ul>
--   <li>Correção da prova de ADS Noite</li>
--   <li>1. (valor 2.5 pontos)</li>
--   <li>(a) (1.0) Monte uma expressão lambda para o que se pede<ul><li>i.
--   Para verificar se o reverso do reverso de uma lista é sempre ela mesmo
--   (isso é usado em testes de software)<pre>(xs -&gt; (<a>reverse</a> .
--   <a>reverse</a>) xs ) </pre></li><li>ii. Para deixar todas as letras
--   com caixa baixa (use o <tt>toLower</tt> :: <a>Char</a> -&gt;
--   <a>Char</a> que deixa um char por vez em caixa baixa)<pre>(xs -&gt;
--   <a>map</a> <tt>toLower</tt> xs ) </pre></li><li>iii. Para verificar se
--   o tamanho de uma lista é par e menor que 144. <pre>(xs -&gt;
--   (<a>mod</a> (<a>length</a> xs) 2) == 0 &amp;&amp; (<a>length</a> xs)
--   &lt; 144) </pre></li><li>iv. Para verficiar o maior entre os números y
--   e 9.<pre>(y -&gt; <a>max</a> y 9) </pre></li></ul></li>
--   <li>(b) (0.5) Dê o tipo, o mais geral possível, dos seguintes
--   lambdas<ul><li>i. x -&gt; [ x &gt; 9 ]<pre>(x -&gt; [ x &gt; 9 ]) ::
--   (<a>Num</a> a, <a>Ord</a> a) =&gt; a -&gt; [<a>Bool</a>]
--   </pre></li><li>ii. k -&gt; [k &lt;&gt; <a>mempty</a>]<pre>(k -&gt; [k
--   &lt;&gt; <a>mempty</a>]) :: <a>Monoid</a> t =&gt; t -&gt; [t]
--   </pre></li></ul></li>
--   <li>(c) (1) Faça funções (dando o tipo da função da forma mais
--   genérica possível) para o que se pede.<ul><li>i. Uma função que receba
--   um Maybe Int e retorna um Maybe Bool indicando se este é positivo.
--   (Usar pattern matching no Maybe).<pre>maybeIntBool :: <a>Maybe</a> Int
--   -&gt; <a>Maybe</a> <a>Bool</a> maybeIntBool <a>Nothing</a> =
--   <a>Nothing</a> maybeIntBool (Just 0) = <a>Nothing</a> maybeIntBool x =
--   <a>Just</a> ( x &lt; 0 ) </pre></li><li>ii. Uma função que receba uma
--   lista e retorne o reverso do reverso dela mesmo.<pre>funR :: [a] -&gt;
--   [a] funR xs = ( <a>reverse</a> . <a>reverse</a> ) xs
--   </pre></li><li>iii. Uma função que receba um numero x e retorne a
--   expressão Just(x == 0).<pre>funX ::(<a>Num</a> a) =&gt; a -&gt;
--   <a>Maybe</a> <a>Bool</a> funX x = <a>Just</a> (x == 0)
--   </pre></li><li>iv. Uma função que verifique se a multiplicação de um
--   vetor de (Product Ints), recebido via parâmetro, é par (Product é um
--   funtor).<pre>prodPar :: (<tt>Product</tt> a)=&gt; [a] -&gt;
--   <a>Bool</a> prodPar ps = ( ( <a>mconcat</a> ps )`<a>mod</a>` 2 ) == 0
--   </pre></li></ul></li>
--   </ul>
exercício1 :: IO ()

-- | <ul>
--   <li>2. (valor 2.5 pontos) Considere a função<pre>module Aula1 where
--   data Tripla a = Tripla a Int a deriving Show instance <a>Functor</a>
--   Tripla where <a>fmap</a> f (Tripla x y z) = Tripla (f x ) (<a>id</a>
--   y) ((<a>id</a> . f . <a>id</a>) z) </pre>e responda<ul><li>(a) (0.25)
--   Qualovalordaexpressão <a>fmap</a> (x -&gt; (<a>head</a> . <a>id</a> .
--   <a>tail</a> . <a>reverse</a>) x) $ Tripla "PHP" 2
--   "HASKELL"?<pre><a>fmap</a> (x -&gt; (<a>head</a> . <a>id</a> .
--   <a>tail</a> . <a>reverse</a>) x) $ Tripla "PHP" 2 "HASKELL" Tripla
--   <tt>H</tt> 2 <tt>L</tt> </pre></li><li>(b) (0.25) Qual o valor da
--   expressão :t Tripla 2.2 0 3.3 ?<pre>Tripla 2.2 0 3.3 ::
--   <a>Fractional</a> a =&gt; Tripla a </pre></li><li>(c) (0.25) Qual o
--   valor de :kind Tripla ?<pre>:k (Tripla ) (Tripla ) :: * -&gt; *
--   </pre></li><li>(d) (0.5) Crie uma expressão lambda para extrai o
--   primeiro elemento dos campos de um Tripla String;<pre>( (Tripla x _ _
--   ) -&gt; x ) </pre></li><li>(e) (0.25) Qual o valor de :t Tripla
--   <a>Nothing</a> 4 <a>Nothing</a>?;<pre>Tripla <a>Nothing</a> 4
--   <a>Nothing</a> :: Tripla (<a>Maybe</a> a) </pre></li><li>(f) (0.5)
--   Duas Triplas são iguais se o terceiro campo o for. Faça essa instância
--   de Eq para Tripla;<pre>instance (<a>Eq</a> a) =&gt; <a>Eq</a> (Tripla
--   a) where (==) (Tripla _ _ x) (Tripla _ _ y) = x == y
--   </pre></li><li>(g) (0.5) Do jeito que está, é possível calcular a
--   expressão Tripla 1 2 3 &lt; Tripla 2 5 9? Justifique.<pre>Não, pois
--   não existe descrição de instância de Ord para
--   Triplas</pre></li></ul></li>
--   </ul>
exercício2 :: IO ()

-- | <ul>
--   <li>3. (valor 2.5 pontos) Crie o tipo Sozinho com um value constructor
--   Sozinho. Crie uma instância de Monoid para este tipo.</li>
--   </ul>
--   
--   <pre>
--   import <tt>Data</tt>.<a>Monoid</a>
--   
--   module Sozinho where 
--   
--   data Sozinho = Sozinho
--   
--   instance <a>Monoid</a> Sozinho where
--       <a>mempty</a> = Sozinho
--       <a>mappend</a> _ _ = Sozinho
--   
--   </pre>
exercício3 :: IO ()

-- | <ul>
--   <li>4. (valor 2.5 pontos) Baseando-se na música do Stealers Wheels
--   (1972) ”Clowns to the left of me Jokers to the right, here i am, stuck
--   in the Middle with you”<ul><li>(a) Crie o tipo Position com os value
--   constructors Clowns, Jokers e Middle<pre>data Position = Clowns |
--   Jokers | Middle deriving Show </pre></li></ul></li>
--   <li>(b) Crie o typeclass (Music a) que implemente a função whereIn ::
--   a −&gt; P osition<pre>class Music a where whereIn :: a -&gt; Position
--   </pre></li>
--   <li>(c) Crie uma instância de Music para Int que faz com que os
--   positivos sejam Clowns, os negativos Jokers e o zero
--   Middle<pre>instance Music Int where whereIn x | x &gt; 0 = Clowns | x
--   &lt; 0 = Jokers | otherwise = Middle </pre></li>
--   <li>(d) Generalize o item acima para qualquer Monoid (lembre-se de
--   colocar as restrições aqui).<pre>instance (<a>Ord</a> a, <a>Monoid</a>
--   a)=&gt; Music a where whereIn x | x &gt; <a>mempty</a> = Clowns | x
--   &lt; <a>mempty</a> = Jokers | otherwise = <a>mempty</a> </pre></li>
--   </ul>
exercício4 :: IO ()


-- | Prova de ADS Manhã Comentários <tt>#Correção de Prova </tt>.
module ADSM

-- | <ul>
--   <li>Correção da prova de ADS Manhã</li>
--   <li>1. (valor 2.5 pontos)</li>
--   <li>(a) (1.0) Monte uma expressão lambda para o que se pede<ul><li>i.
--   Para verificar se um valor é diferente de seu mempty<pre>(x -&gt; x /=
--   <a>mempty</a> ) </pre></li><li>ii. Para retornar o reverso de uma
--   lista xs concatenada com a própria xs.<pre>(xs -&gt; (<a>reverse</a>
--   xs) ++ xs ) </pre></li><li>iii. Para verificar se o tamanho de uma
--   lista é ímpar e maior que 7.<pre>(xs -&gt; (<a>mod</a> (<a>length</a>
--   xs) 2) == 1 &amp;&amp; (<a>length</a> xs) &gt; 7) </pre></li><li>iv.
--   Para verficiar o maior entre os números x e 0.<pre>(x -&gt; <a>min</a>
--   x 0) </pre></li></ul></li>
--   <li>(b) (0.5) Dê o tipo, o mais geral possível, dos seguintes
--   lambdas<ul><li>i. :t (x -&gt; <a>Just</a> $ x &lt;&gt;
--   <a>Ola</a>)<pre>(x -&gt; <a>Just</a> $ x &lt;&gt; <a>Ola</a>) ::
--   [<a>Char</a>] -&gt; <a>Maybe</a> [<a>Char</a>] </pre></li><li>ii. :t k
--   -&gt; <a>Just</a> $ k == <a>False</a><pre>(k -&gt; <a>Just</a> $ k ==
--   <a>False</a>) :: <a>Bool</a> -&gt; <a>Maybe</a> <a>Bool</a>
--   </pre></li></ul></li>
--   <li>(c) (1) Faça funções (dando o tipo da função e da forma mais
--   genérica possível) para o que se pede<ul><li>i. Uma função que
--   verifique se a soma de um vetor de Ints, recebido via parâmetro, é
--   par.<pre>funSomaPar :: [<a>Int</a>] -&gt; <a>Bool</a> funSomaPar xs =
--   ((<a>foldl</a> (+) 0 xs) <a>mod</a> 2) == 0 </pre></li><li>ii. Uma
--   função que receba um Maybe Int e retorna um Maybe Bool indicando se
--   este é negativo. Usar pattern matching no Maybe).<pre>funMaybe ::
--   <a>Maybe</a> <a>Int</a> -&gt; <a>Maybe</a> <a>Bool</a> funMaybe
--   <a>Nothing</a> = <a>Nothing</a> funMaybe (<a>Just</a> x) = <a>Just</a>
--   (x &gt;= 0) </pre></li><li>iii. Uma função que receba uma lista e
--   filtre os memptys.<pre>filtrarMemptys :: (Eq a, Monoid a) =&gt; [a]
--   -&gt; [a] filtrarMemptys xs = <a>filter</a> ( /= <a>mempty</a>) xs
--   </pre></li><li>iv. Uma função que receba um vetor de Int (de tamanho
--   qualquer) e retorne a soma dos quadrados dos elementos. (Exemplo: se a
--   entrada for [0,2,1] o retorno deve ser 5).<pre>retornaQuad ::
--   [<a>Int</a>] -&gt; <a>Int</a> retornaQuad [] = 0 retornaQuad (x:xs) =
--   (x * x) + retornaQuad xs </pre></li></ul></li>
--   </ul>
exercício1 :: IO ()

-- | <ul>
--   <li>2. (valor 2.5 pontos) Considere a função<pre>module Aula1 where
--   data Tripla a = Tripla a Int a deriving Show instance <a>Functor</a>
--   Tripla where <a>fmap</a> f (Tripla x y z) = Tripla (f x ) (<a>id</a>
--   y) ((<a>id</a> . f . <a>id</a>) z) </pre></li>
--   </ul>
--   
--   e responda
--   
--   <ul>
--   <li>(a) (0.25)Qual o valor da expressão fmap (x -&gt; (<a>tail</a> .
--   <a>tail</a> . <a>reverse</a>) x)$ Tripla <a>PHP</a> 2
--   <a>HASKELL</a>?</li>
--   </ul>
--   
--   <pre>
--   Tripla "P" 2 "EKSAH"
--   
--   </pre>
--   
--   <ul>
--   <li>(b) (0.25) Qual o valor da expressão :t Tripla "." 0
--   <a>OLA</a>?</li>
--   </ul>
--   
--   <pre>
--   Tripla "." 0 "OLA" :: Tripla [<a>Char</a>]
--   
--   </pre>
--   
--   <ul>
--   <li>(c) (0.25) Qual o valor de :kind (Tripla <a>Int</a>)?<pre>:k
--   (Tripla <a>Int</a>) (Tripla <a>Int</a>) :: * </pre></li>
--   <li>(d) (0.5) Crie uma expressão para dobra todos os campos de um
--   Tripla Int;<pre>((Tripla x y z)-&gt; Tripla (x * 2) (y * 2) (z * 2) )
--   </pre></li>
--   <li>(e) (0.25) Qual o valor de :t Tripla <a>False</a> 4
--   <a>True</a>?;</li>
--   </ul>
--   
--   <pre>
--   :t Tripla <a>False</a> 4 <a>True</a>
--   Tripla <a>False</a> 4 <a>True</a> :: Tripla <a>Bool</a>
--   
--   </pre>
--   
--   <ul>
--   <li>(f) (0.5) Faça uma função chamada homs que receba Tripla a e
--   retorne (a,Int,a) colocando cada campo na respectiva coordenada.
--   Exemplo, homs (Tripla ’w’ 7 ’p’) retorna o valor (’w’,7,’p’);</li>
--   </ul>
--   
--   <pre>
--   homs :: (Tripla a) -&gt; ( a , Int , a )
--   homs (Tripla x y z) = (x,y,z)
--   
--   </pre>
--   
--   <ul>
--   <li>(g) (0.5) Do jeito que está, é possível calcular a expressão
--   Tripla 1 2 3 &lt;&gt; Tripla 1 2 3? Justifique.<pre>Não é possível,
--   não existe instância de monoid. Então o haskell não sabe como combinar
--   dois tipos "Tripla"</pre></li>
--   </ul>
exercício2 :: IO ()

-- | <ul>
--   <li>3. (valor 2.5 pontos) Implemente o tipo de nome GF3 contendo os
--   value constructors U, A, B e C. Implemente uma instância de Monoid
--   seguindo a tabela abaixo.</li>
--   </ul>
--   
--   <pre>
--   &lt;&gt; U A B
--   U  U A B 
--   A  A B U
--   B  B U A
--   </pre>
--   
--   
--   <pre>
--   import Data.Monoid
--   
--   module GF3 where 
--   
--   data GF3 = U | A | B  deriving Show
--   
--   instance <a>Monoid</a> GF3 where
--     <a>mempty</a> = U 
--     <a>mappend</a> U U = U
--     <a>mappend</a> U A = A
--     <a>mappend</a> U B = B
--     <a>mappend</a> A U = A
--     <a>mappend</a> A A = B
--     <a>mappend</a> A B = U
--     <a>mappend</a> B U = B
--     <a>mappend</a> B A = U
--     <a>mappend</a> B B = A
--   
--   </pre>
exercício3 :: IO ()

-- | <ul>
--   <li>4. (valor 2.5 pontos)</li>
--   <li>(a) Crie o tipo EstadoLampada com os value constructors Aceso e
--   Apagado. (b) Implemente a função click que troca o estado da
--   lâmpada.<pre> data EstadoLampada = Aceso | Apagado deriving (Show,Eq)
--   click :: EstadoLampada -&gt; EstadoLampada' click Aceso = Apagado
--   click Apagado = Aceso </pre><ul><li>(c) Faça uma função que filtre as
--   lâmpadas apagadas de uma lista.<pre>filtraApagadas :: [EstadoLampada]
--   -&gt; [EstadoLampada] filtraApagadas xs = <a>filter</a> (Aceso == x)
--   xs </pre></li><li>(d) Faca uma função que troque o estado de todas as
--   lâmpadas de uma lista<pre>funTroca :: [EstadoLampada] -&gt;
--   [EstadoLampada] funTroca xs = <a>map</a> click xs </pre></li><li>(e)
--   Faça uma instância de Show para este tipo escrevendo uma mensagem
--   diferente para cada estado<pre>instance Show EstadoLampada where show
--   Aceso = "Plim" show Apagado = "Good Night" </pre></li></ul></li>
--   </ul>
exercício4 :: IO ()
